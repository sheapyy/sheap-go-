2025.12.30

今天写了一点go中的web服务，感觉还可以，但是一涉及到结构体之间的调用和routine以及读写锁，就感觉理解起来有点困难，主要还是不熟练吧，但是具体对于每个模块实现了什么事情我还是清楚的，下面讲一讲今天的收获。

1.关于怎么开启一个web服务？
go里面有十分成熟且易用的web服务包htp/net.
比如说我要在本地开启一个web网页，就可以调用这个函数:
http.ListenAndServe()。
这个函数里面有两个参数，第一个是网页的地址，第二个是一个回调函数。
目前我只学习到了最简单的部分，即http.ListenAndServe("localhost:8000",nil),这样就在localhost:8000这个地方创建了一个网页。
那么怎么判断这个网页创建是否成功呢，我们需要传入一个参数

即err :=http.ListenAndServe("localhost:8000",nil)  
  if err != nil {
  		fmt.Println("服务器启动失败", err)
  	}
这样就开启了一个最简单的web服务。

2.怎么在我们自己的web上加点东西？
我们平时所接触的网页下都会有很多子服务，比如baidu.com/test/hello 这种，那么我们怎么在当前的页面下添加这样的路径呢？
go为我们提供了很简单的函数，http.HandleFunc()
这个函数有两个要传入的参数，一个是这个页面的路径，比如"/test"，另一个是一个回调函数，这个函数要实现的是这个页面下的网站的功能。
我们可以这么写一个简单的欢迎页面:
http.HandleFunc("/",homeHandler)
http.HandleFunc("/hello",helloHandler)
这样我们在访问诸如"localhost:8000"以及"localhost:8000/hello"下会有新的页面，接下来我们来编写回调函数，就是当前页面下实现的功能。
首先我们来写主页面的

func homeHandler(w,http.ResponseWriter, r *http.Request) {
w.Header().Set("Content-Type", "text/html; charset=utf-8")
html := `
<h1>这是我的第一个web程序<h1>
<a href="/hello">访问hello页面</a><br>
`
fmt.Fprint(w,html)
}<>

对于上述代码来说，r是用户的请求，就好比餐厅里的客人点菜；w是我们的相应，要为用户上什么菜。接着第一行代码实现了一个网页的定义，意思是我们要使用html语言来写当前的页面，编码采用的是utf-8
对于html来说，首先这类特殊的语言都得放在``里面，json的也是这样的。然后<h1><h1>就是第一个大标题，同理也会有h2 h3 h4。<p></p>就是写一段文字然后<a href=></a>就是提供一个链接，点击就能转到链接所在的页面。<br>就是换行
当然也有一种更加有结构化的写法
<p>API 端点: </p>
	<ul>
	<li><a href="/api/tasks">GET /api/tasks - 获取所有任务</a></li>
	</ul>
这就是关于html的知识。
然后是hello页面的写法
func helloHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	fmt.Fprintf(w, "<h1>Hello Go Web!<h1><p>请求方法: %s</p>", r.Method)
	fmt.Fprintf(w, "<h1>Hello Go Web!<h1><p>用户信息: %s</p>", r.Header.Get("User-Agent"))
}
也是类似的，不过我们看到我们可以在接收端对用户发来的信息做解析，比如r.Method返回的是用户的请求方式，我的结果是Get，然后也可以查看用户的浏览器信息。

这里涉及到Fprint和Fprintf之间的区别。我查了下，前者是简单的字符串拼接，后者有点像c里面的printf需要加占位符，更加富有格式化。
后续还涉及到了存储和读写锁这些东西，虽然抄完了，但是我也没看懂，还得消化一下。

2026.1.4

元旦假期终于结束了，又要开始苦逼的研究生生涯了。
今天来总结下先前学习的时候遇到的问题。

先说下go中的锁的问题。在一个web服务中，更改内容的时候必须一个一个来，所以常用的写法就是在回调函数前写一个 mu.lock()和defer mu.unlock
写一个锁一个。但是这种方法在实际中遇到大量的请求时肯定会遇到很多问题，于是在企业开发中往往会用到redis和数据库这种混合的东西，但是这个地方我还没学，所以后续再说。

然后时html中的一个新的语句就是未定义的列表，语法见下文
<ul>
//这里面写东西
	<li>
			意思是list item，即这个列表里面要存放的东西
			<strong>加粗里面的文本</strong>
	</li>
</ul>

json.NewEncoder().Encode()和json.NewDecoder().Decode()的用法
先说编码，目前来说我所接触到的地方，通常都是在web服务中的回调函数部分使用，NewEncoder()括号里面放的就是 w http.ResponseWriter，然后Encode()括号里面放带`json:""`的结构体，这样就能将结构体中的内容转换为字符串呈现在web页面上，编码似乎是不需要修改原来的结构体的，所以不需要指针指向。
再说解码，解码应该是用来处理用户的请求的。比如clinet端返回一个修改后的任务，然后在回调函数中就是指向http.Request的指针r就是要去接受这个请求，所以NewDecoder()中是r.Body，然后Decode()中是指向传入的结构体的指针，就可以对这个传入的结构体做一些修改和读取的操作。
所以总而言之，编码操作是将结构体转换为json字符串，最终在服务端上向用户呈现出来；解码操作是将json字符串转换为结构体，然后修改数据库里面的数据

2026.1.5

今天让ai写了个前端，然后我这边用后端。马上要开始搞数据库连接了，但是今天没学习到什么新东西，
只学到了前端页面在后端怎么写，其实非常简单。
func frontendHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	http.ServeFile(w, r, "./static/index.html")
}
关于html和java的部分我没怎么看，我觉得这不是重点，以后工作了应该就会学到了。
明天的数据库是重头戏，得认真学。
md今天这b课题，真难搞，不过这东西就是斗争，失败，再斗争，再失败，再斗争，直至成功的过程。

2025.1.6

又是燃尽的一天，探索了一天的优化模型没有出一个挺好的结果，不过已经排了很多个坑了，我感觉胜利就在眼前了，再坚持一下，天快亮了。

然后步入正题，说数据库在go里面的调用。
首先我们先在sql里面配置好要使用的数据库，这里就不再赘述了。
然后在go里面要设置一个指向你的 数据库的指针
var db *sql.DB 这是个全局指针，用这个操作数据库
那么怎么让这个指向你的数据库呢，通过下面这个函数
dsn := "root:123456@tcp(127.0.0.1:3306)/task_manager?parseTime=true&charset=utf8mb4"
格式为 用户名:密码@tcp(数据库端口)/数据库名字
db, err = sql.Open("mysql", dsn)
注意数据库随时关闭连接
defer db.Close()
为了节省效率，不要一个一个连接，每个用户用tcp连接很慢，要放在一个连接池里，才能节省速度。
db.SetMaxOpenConns(25)                 //最大连接次数
db.SetMaxIdleConns(5)                  //最大空闲连接数
db.SetConnMaxLifetime(5 * time.Minute) //连接最大生命周期
然后数据库中的内容怎么读呢，我们需要写sql的脚本
比如
query := "SELECT id, title, description, completed, created_at, updated_at FROM tasks ORDER BY id DESC"
rows, err := db.Query(query) 用db.Query()去读
在一些增删改查的程序中需要用到参数，我们在query中用?代表占位符
query := "SELECT id, title, description, completed, created_at, updated_at FROM tasks WHERE id = ?"
row := db.QueryRow(query, id)
query和queryrow区别？前者是查询多行，后者是一行。
这样就存储好了，我们还需要读取到具体的每一个元素是什么，利用
for rows.Next() {
		var task Task
		err := rows.Scan(
			&task.ID,
			&task.Title,
			&task.Description,
			&task.Completed,
			&task.CreatedAt,
			&task.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, task)
	}
scan()用于存储具体的元素
然后查询的时候用query，等到增删改的时候就要用db.exec()
query := "DELETE FROM tasks WHERE id = ?"
result, err := db.Exec(query, id)
判断行是不是空行rowsAffected()
rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return nil
	}

困了，明天还得搞Gin框架重构代码，这是真正的重头戏

2025.1.14
已经完成了使用GIN框架重构的web网站，具体的版本解释将放在后面一个新开的，包含所有完整代码及解释的文件中

